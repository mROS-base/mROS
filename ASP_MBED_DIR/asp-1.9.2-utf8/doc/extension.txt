
		TOPPERS/ASPカーネル
		機能拡張・チューニングガイド

		対応バージョン: Release 1.9.2
		最終更新: 2014年1月2日

このドキュメントは，TOPPERS/ASPカーネルを，機能拡張・チューニングするた
めの方法（またはヒント）を説明するものである．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2014 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)～(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: extension.txt 2728 2015-12-30 01:46:11Z ertl-honda $
----------------------------------------------------------------------

○目次

・エラーチェックの省略
・タイムティックの周期の変更
・特殊目的のレジスタの扱い
・拡張パッケージの使い方
	- ミューテックス機能拡張パッケージ
	- メッセージバッファ機能拡張パッケージ
	- オーバランハンドラ機能拡張パッケージ
	- タスク優先度拡張パッケージ
	- 制約タスク拡張パッケージ
	- 動的生成機能拡張パッケージ
・CPU例外ハンドラの直接呼出し
	- TA_DIRECT属性の導入
	- ターゲット依存部の修正箇所


○エラーチェックの省略

サービスコールのオーバヘッドを削減するために，静的なエラーのチェックを
省略する場合がある．ASPカーネルにおいては，静的なエラーのチェックはすべ
てCHECKマクロを用いて行っているため，kernel/check.h中のCHECKマクロを編
集することで，静的なエラーのチェックを省略することができる．

例えば，タスクIDのチェックを省略したい場合には，CHECK_TSKIDマクロと
CHECK_TSKID_SELFマクロを，次のように修正すればよい．

#define CHECK_TSKID(tskid)			((void)(tskid))
#define CHECK_TSKID_SELF(tskid)		((void)(tskid))

これらのマクロの定義を空にする方法もあるが，パラメータに副作用のある式
が書かれている可能性を考えると（副作用のある式は書くべきではないが，書
かれているコードが入ってくる可能性が全くないとは言えない），上の定義の
方が安全である．副作用のない式であれば，最適化によって削除することがで
きるため，実行時効率には影響がないと期待できる．ただし，最適化によって
削除されない場合には，副作用のある式が書かれていないことを確認した上で，
マクロの定義を空にしてもよい．


○タイムティックの周期の変更

ASPカーネルでは，カーネルへタイムティックを供給する周期は1ミリ秒が標準
となっているが，低速なプロセッサでは1ミリ秒毎に割込みを処理するオーバヘッ
ドが問題になる場合がある．そこで，アプリケーションが必要とする時間精度
が粗い場合には，タイムティックの周期を長くすることで，プロセッサの処理
負荷を低減する方法がある．

タイムティックの周期の与え方はターゲット依存であるため，これが変更でき
るかどうかは，ターゲット依存部のタイマドライバの実装を調べる必要がある．
標準的には，target_kernel.h（またはそこからインクルードされるファイル）
中に定義されているTIC_NUMEとTIC_DENOを書き換えることで，変更できるよう
に実装されている．


○特殊目的のレジスタの扱い

FPUレジスタやDSPレジスタなどの特殊目的のレジスタ（以下，特殊レジスタ）
を持つプロセッサでは，レジスタの扱いについて大きく次の3つの方法が考えら
れる．

(1) 特殊レジスタをタスクのコンテキストに含めない

1つのタスクのみが特殊レジスタを使用する場合には，特殊レジスタをタスクの
コンテキストに含める必要がなく，カーネルで管理する必要がない．

(2) 特殊レジスタをタスクのコンテキストに含める

複数のタスクが特殊レジスタを使用する場合には，特殊レジスタをタスクのコ
ンテキストに含める方法が最も単純である．そのためには，タスクディスパッ
チャと割込みハンドラ/CPU例外ハンドラの出入口で，特殊レジスタを保存/復帰
するコードを追加する必要がある．実際の保存/復帰場所は，スクラッチレジス
タとそれ以外のレジスタで異なるため，注意が必要である．

(3) 特殊レジスタをコンテキストに含めるかどうかをタスク毎に指定する

特殊レジスタを使用するタスクと使用しないタスクがある場合で，すべてのタ
スクのコンテキストに特殊レジスタを含める方法ではオーバヘッドが問題にな
る場合には，特殊レジスタをコンテキストに含めるかどうかをタスク毎に指定
する方法が有力である．これを実現する方法は次の通りである．

まず，特殊レジスタをコンテキストに含めるかどうかを指定するタスク属性を
設ける．例えば，FPUレジスタであれば，タスク属性にTA_FPUを設ける．タスク
ディスパッチャでは，タスク属性を見て，その属性が設定されていれば特殊レ
ジスタを保存/復帰する．

ハードウェア的に特殊レジスタがディスエーブルできる場合には，その属性が
設定されていないタスクに切り換える時に特殊レジスタをディスエーブルする
と，誤って特殊レジスタを使った場合を検出できる．

さらに，割込みハンドラ（ISR，周期ハンドラ，アラームハンドラを含む）や
CPU例外ハンドラで特殊レジスタを使用する場合には，これらの処理単位にも
特殊レジスタを使用するかどうかの属性を設ける方法が考えられる．

ここで，タスク（または他の処理単位）が特殊レジスタを使用するかどうかは，
コンパイラやライブラリに依存する場合があるため，注意が必要である．例え
ば，浮動小数点演算を含まないプログラムであっても，コンパイラがその方が
性能が高いと判断すれば，浮動小数点命令を生成する場合がある．


○拡張パッケージの使い方

ASPカーネルでは，いくつかの拡張機能を実装するために，拡張パッケージをサ
ポートしている．拡張パッケージは，extensionディレクトリに置いてある．

拡張パッケージを使用する場合には，UNIXであれば，ASPカーネルのソースファ
イルのトップディレクトリで，

	% cp -r extension/<拡張パッケージのディレクトリ名>/* .

を実行する．この時，元の（拡張前の）ソースファイルは上書きされてしまう
ため，拡張しないカーネルも使用したい場合には，別のディレクトリにソース
ファイルを展開して，上のコマンドを実行すること．

複数の拡張パッケージを使うことは考慮していないが，以下に述べるケースを
除いては，手作業により複数の拡張パッケージをマージすることは可能である．
現時点では，ミューテックス機能拡張パッケージと制約タスク拡張パッケージ
をマージすることはできない．また，動的生成機能拡張パッケージを他の拡張
パッケージとマージすることは考慮していない．

●ミューテックス機能拡張パッケージ

ミューテックス機能拡張パッケージは，ミューテックス機能を追加するための
拡張パッケージである．ただし，優先度逆転を制御するための仕組みとして，
優先度上限ミューテックス（TA_CEILING属性のミューテックス）のみをサポー
トし，優先度継承ミューテックス（TA_INHERIT属性のミューテックス）はサポー
トしていない．ミューテックス機能拡張パッケージは，extension/mutexディレ
クトリに置いてある．

ミューテックス機能拡張パッケージでは，TOPPERS_SUPPORT_MUTEXがkernel.h中
で定義されているので，これを用いてミューテックス機能を使用できるかどう
かを判別することができる．

●メッセージバッファ機能拡張パッケージ

メッセージバッファ機能拡張パッケージは，メッセージバッファ機能を追加す
るための拡張パッケージである．メッセージバッファ機能拡張パッケージは，
extension/messagebufディレクトリに置いてある．

メッセージバッファ機能拡張パッケージでは，TOPPERS_SUPPORT_MESSAGEBUFが
kernel.h中で定義されているので，これを用いてメッセージバッファ機能を使
用できるかどうかを判別することができる．

●オーバランハンドラ機能拡張パッケージ

オーバランハンドラ機能拡張パッケージは，オーバランハンドラ機能を追加す
るための拡張パッケージである．ただし，この拡張パッケージを使うためには，
ターゲット依存部が対応している必要がある．オーバランハンドラ機能拡張パッ
ケージは，extension/ovrhdrディレクトリに置いてある．

オーバランハンドラ機能拡張パッケージで，ターゲット依存部が拡張パッケー
ジに対応している場合には，TOPPERS_SUPPORT_OVRHDRがkernel.h中で定義され
るので，これを用いてオーバランタイマ機能が使用できるかどうかを判別する
ことができる．

●タスク優先度拡張パッケージ

タスク優先度拡張パッケージは，タスク優先度を最大256段階に拡張するための
拡張パッケージである．この拡張パッケージは，タスク優先度に加えて，デー
タ優先度，メッセージ優先度，割込みサービスルーチン優先度も256段階に拡張
する．タスク優先度拡張パッケージは，extension/pri_levelディレクトリに置
いてある．

タスク優先度拡張パッケージでは，TOPPERS_SUPPORT_PRI_LEVELがkernel.h中で
定義されているので，これを用いてタスク優先度の範囲が拡張されているかど
うかを判別することができる．

●制約タスク拡張パッケージ

制約タスク拡張パッケージは，制約タスクの機能を追加するための拡張パッケー
ジである．TOPPERS新世代カーネル統合仕様書に規定された制約タスクの機能に
加えて，自タスクのベース優先度を変更するサービスコールras_priを実装して
いる．制約タスク拡張パッケージは，extension/rstr_taskディレクトリに置い
てある．

制約タスク拡張パッケージでは，TOPPERS_SUPPORT_RSTR_TASKがkernel.h中で定
義されているので，これを用いて制約タスクの機能が使用できるかどうかを判
別することができる．

----------------------------------------------------------------------
ras_pri		自タスクのベース優先度の引き上げ〔T〕

【C言語API】
	ER ercd = ras_pri(PRI tskpri)

【パラメータ】
	PRI			tskpri		ベース優先度

【リターンパラメータ】
	ER			ercd		正常終了（E_OK）またはエラーコード

【エラーコード】
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し
				・CPUロック状態からの呼出し
	E_PAR		パラメータエラー
				・tskpriが有効範囲外
	E_ILUSE		サービスコール不正使用
				・条件については機能の項を参照

【機能】

自タスクのベース優先度を，tskpriで指定した優先度に変更する．具体的な振
舞いは以下の通り．

自タスクのベース優先度が，tskpriで指定した優先度に変更される．それに伴っ
て，自タスクの現在優先度も変更される．同じ優先度のタスクの中では，自タ
スクが最高優先順位となる．

tskpriにTPRI_INI（＝0）を指定すると，自タスクのベース優先度が，起動時優
先度に変更される．

tskpriは，自タスクの起動時優先度と同じかそれよりも高くなければならない．
そうでない場合には，E_ILUSEエラーとなる．
----------------------------------------------------------------------

●動的生成機能拡張パッケージ

動的生成機能拡張パッケージは，オブジェクトの動的生成機能を追加するため
の拡張パッケージである．TOPPERS新世代カーネル統合仕様書に規定された以下
のオブジェクト生成／削除のためのサービスコール，割付け可能なID番号の数
を指定する静的APIに加えて，カーネルが割り付けるメモリ領域を設定する静的
API DEF_KMMを実装している．動的生成機能拡張パッケージは，extension/dcre
ディレクトリに置いてある．

ただし，カーネル内での動的メモリ管理に関しては，ターゲット非依存部では，
メモリ領域を先頭から順に割り当て，解放されたメモリ領域を再利用しないメ
モリ管理モジュールのみを実装している．本格的な動的メモリ管理を行いたい
場合には，ターゲット依存部またはユーザ側で，そのための関数を用意する必
要がある．用意する関数等については，「TOPPERS/ASPカーネル ターゲット依
存部 ポーティングガイド」の「6.15 動的メモリ管理」の節を参照すること．

動的機能拡張拡張パッケージでは，TOPPERS_SUPPORT_DYNAMIC_CREがkernel.h中
で定義されているので，これを用いて動的生成機能が使用できるかどうかを判
別することができる．

動的生成機能拡張パッケージにより追加されるサービスコール

	ER_ID tskid = acre_tsk(const T_CTSK *pk_ctsk)
	ER ercd = del_tsk(ID tskid)
	ER ercd = def_tex(ID tskid, const T_DTEX *pk_dtex)
	ER_ID semid = acre_sem(const T_CSEM *pk_csem)
	ER ercd = del_sem(ID semid)
	ER_ID flgid = acre_flg(const T_CFLG *pk_cflg)
	ER ercd = del_flg(ID flgid)
	ER_ID dtqid = acre_dtq(const T_CDTQ *pk_cdtq)
	ER ercd = del_dtq(ID dtqid)
	ER_ID pdqid = acre_pdq(const T_CPDQ *pk_cpdq)
	ER ercd = del_pdq(ID pdqid)
	ER_ID mbxid = acre_mbx(const T_CMBX *pk_cmbx)
	ER ercd = del_mbx(ID mbxid)
	ER_ID mpfid = acre_mpf(const T_CMPF *pk_cmpf)
	ER ercd = del_mpf(ID mpfid)
	ER_ID cycid = acre_cyc(const T_CCYC *pk_ccyc)
	ER ercd = del_cyc(ID cycid)
	ER_ID almid = acre_alm(const T_CALM *pk_calm)
	ER ercd = del_alm(ID almid)
	ER_ID isrid = acre_isr(const T_CISR *pk_cisr)
	ER ercd = del_isr(ID isrid)

動的生成機能拡張パッケージにより追加される静的API

	AID_TSK(uint_t notsk)
	AID_SEM(uint_t nosem)
	AID_FLG(uint_t noflg)
	AID_DTQ(uint_t nodtq)
	AID_PDQ(uint_t nopdq)
	AID_MBX(uint_t nombx)
	AID_MPF(uint_t nompf)
	AID_CYC(uint_t nocyc)
	AID_ALM(uint_t noalm)
	AID_ISR(uint_t noisr)
	DEF_KMM({ SIZE kmmsz, STK_T *kmm })

----------------------------------------------------------------------
DEF_KMM		カーネルが割り付けるメモリ領域の設定〔SD〕

【静的API】
	DEF_KMM({ SIZE kmmsz, STK_T *kmm })

【パラメータ】
　＊カーネルが割り付けるメモリ領域の設定情報
	SIZE		kmmsz		カーネルが割り付けるメモリ領域のサイズ（バイト数）
	STK_T		kmm			カーネルが割り付けるメモリ領域の先頭番地

【エラーコード】
	E_PAR		パラメータエラー
				・kmmszが0以下
				・その他の条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・カーネルが割り付けるメモリ領域が設定済み

【機能】

各パラメータで指定したカーネルが割り付けるメモリ領域の設定情報に従って，
カーネルが割り付けるメモリ領域を設定する．

kmmszは整数定数式パラメータ，kmmは一般定数式パラメータである．

kmmをNULLとした場合，kmmszで指定したサイズのメモリ領域を，コンフィギュ
レータが確保する．kmmszにターゲット定義の制約に合致しないサイズを指定し
た時には，ターゲット定義の制約に合致するようにサイズを大きい方に丸めて
確保する．

カーネルが割り付けるメモリ領域をアプリケーションで確保する場合には，
kmmszで指定したサイズのメモリ領域を確保し，kmmにその先頭番地を指定する．

DEF_KMMによりカーネルが割り付けるメモリ領域を設定しない場合，カーネルが
割り付けるメモリ領域は確保されない．

kmmやkmmszにターゲット定義の制約に合致しない先頭番地やサイズを指定した
時には，E_PARエラーとなる．
----------------------------------------------------------------------


○CPU例外ハンドラの直接呼出し

CPU例外ハンドラの出入口処理は，CPU例外が発生しないように実装しなければ
ならないが，これが防げないターゲットにおいては，CPU例外ハンドラの出入口
処理を経由せずに，アプリケーションが用意したCPU例外ハンドラを直接実行す
る方法を用意するのが望ましい．これを，CPU例外ハンドラの直接呼出しと呼ぶ．

ここでは，ハードウェアでベクタテーブルを持つプロセッサにおいて，ターゲッ
ト依存部のみの修正により，CPU例外ハンドラの直接呼出しの機能を追加する方
法について説明する．

●TA_DIRECT属性の導入

CPU例外ハンドラの直接呼出しを指定するために，CPU例外ハンドラ属性に，
TA_DIRECT属性を導入する．

●ターゲット依存部の修正箇所

TA_DIRECTの値を，target_kernel.h（または，そこからインクルードされるファ
イル）で定義し，その値をコンフィギュレータが取り出せるように，
target_def.csv（または，それに代わるファイル）に次の行を追加する．

TA_DIRECT,TA_DIRECT

次に，target.tf（または，そこからインクルードされるファイル）で，
TARGET_EXCATRに設定される値に，TA_DIRECTを追加する．例えば，他のターゲッ
ト依存のCPU例外ハンドラ属性がない場合には，次のように設定する．

$TARGET_EXCATR = TA_DIRECT$

次に，OMIT_INITILIZE_EXCEPTIONを用いて，CPU例外ハンドラの出入口処理を生
成するための記述とCPU例外ハンドラ初期化ブロックの標準の定義が生成される
のを抑止し，それによって抑止される部分をtarget.tfにコピーした上で，以下
の修正を加える．

CPU例外ハンドラの出入口処理を生成するための記述（EXCHDR_ENTRYのリスト）
を生成する部分は，次のように修正する．

$FOREACH excno EXC.ORDER_LIST$
	$IF (EXC.EXCATR[excno] & TA_DIRECT) == 0$
		EXCHDR_ENTRY($EXC.EXCNO[excno]$, $+EXC.EXCNO[excno]$, $EXC.EXCHDR[excno]$)$NL$
	$END$
$END$

また，CPU例外ハンドラ初期化ブロックの定義を生成する部分は，次のように修
正する．

$IF LENGTH(EXC.ORDER_LIST)$
	const EXCINIB _kernel_excinib_table[TNUM_EXCNO] = {$NL$
	$JOINEACH excno EXC.ORDER_LIST ",\n"$
		$IF (EXC.EXCATR[excno] & TA_DIRECT) == 0$
			$TAB${ ($EXC.EXCNO[excno]$), ($EXC.EXCATR[excno]$), (FP)(EXC_ENTRY($EXC.EXCNO[excno]$, $EXC.EXCHDR[excno]$)) }
		$ELSE$
			$TAB${ ($EXC.EXCNO[excno]$), ($EXC.EXCATR[excno]$), (FP)($EXC.EXCHDR[excno]$) }
		$END$
	$END$$NL$
	};$NL$
$ELSE$
	TOPPERS_EMPTY_LABEL(const EXCINIB, _kernel_excinib_table);$NL$
$END$

以上
